#
# The following entries are meant for testing the parser, ensuring
# the right values are passed down to the executor, for all possible
# syntax combinations.
#
# Test basic syntax.
#
create table t1 (a int);
create table t_keyword (`offset` int);
insert into t1 values (1), (1), (2), (3), (2);
insert into t_keyword values (1), (1), (2), (3), (2);
#
# Make sure the FETCH clause addition didn't introduce problems with
# the offset keyword.
#
select * from t1
order by a
offset 2;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near '' at line 3
#
# Offset is now a reserved keyword. Column names can not have that name
# without escaping the identifier.
#
select * from t_keyword
order by offset;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near 'offset' at line 2
select * from t_keyword
order by `offset`;
offset
1
1
2
2
3
#
# Test syntax without a specific limit. (implicit one row)
# Test the alias between row / rows and first / next.
# Test ONLY vs WITH TIES.
#
# Cover also the presence of offset before or after FETCH clause.
#
select * from t1
fetch first row only;
a
1
select * from t1
fetch first rows only;
a
1
select * from t1
fetch next row only;
a
1
select * from t1
fetch next rows only;
a
1
#
# Include offset before fetch clause.
#
select * from t1
order by a
offset 2
fetch first row only;
a
2
select * from t1
order by a
offset 2
fetch first rows only;
a
2
select * from t1
offset 2
fetch next row only;
a
2
select * from t1
offset 2
fetch next rows only;
a
2
#
# Include offset after fetch clause.
#
select * from t1
order by a
fetch first row only
offset 2;
a
2
select * from t1
order by a
fetch first rows only
offset 2;
a
2
select * from t1
order by a
fetch next row only
offset 2;
a
2
select * from t1
order by a
fetch next rows only
offset 2;
a
2
#
# Repeat the tests, but now with WITH TIES.
# WITH TIES requires order by.
#
select * from t1
fetch first row with ties;
ERROR HY000: WITH TIES requires ORDER BY clause to be present
select * from t1
fetch first rows with ties;
ERROR HY000: WITH TIES requires ORDER BY clause to be present
select * from t1
fetch next row with ties;
ERROR HY000: WITH TIES requires ORDER BY clause to be present
select * from t1
fetch next rows with ties;
ERROR HY000: WITH TIES requires ORDER BY clause to be present
select * from t1
order by a
fetch first row with ties;
a
1
1
select * from t1
order by a
fetch first rows with ties;
a
1
1
select * from t1
order by a
fetch next row with ties;
a
1
1
select * from t1
order by a
fetch next rows with ties;
a
1
1
#
# Include offset before fetch clause.
#
select * from t1
order by a
offset 2
fetch first row with ties;
a
2
2
select * from t1
order by a
offset 2
fetch first rows with ties;
a
2
2
select * from t1
order by a
offset 2
fetch next row with ties;
a
2
2
select * from t1
order by a
offset 2
fetch next rows with ties;
a
2
2
#
# Include offset after fetch clause.
#
select * from t1
fetch first row with ties
offset 2;
ERROR HY000: WITH TIES requires ORDER BY clause to be present
select * from t1
order by a
fetch first row with ties
offset 2;
a
2
2
select * from t1
order by a
fetch first rows with ties
offset 2;
a
2
2
select * from t1
order by a
fetch next row with ties
offset 2;
a
2
2
select * from t1
order by a
fetch next rows with ties
offset 2;
a
2
2
#
# Test syntax with a specific limit
#
select * from t1
fetch first 3 row only;
a
1
1
2
select * from t1
fetch first 3 rows only;
a
1
1
2
select * from t1
fetch next 3 row only;
a
1
1
2
select * from t1
fetch next 3 rows only;
a
1
1
2
#
# Include offset before fetch clause.
#
select * from t1
order by a
offset 2
fetch first 3 row only;
a
2
2
3
select * from t1
order by a
offset 2
fetch first 3 rows only;
a
2
2
3
select * from t1
offset 2
fetch next 3 row only;
a
2
3
2
select * from t1
offset 2
fetch next 3 rows only;
a
2
3
2
#
# Include offset after fetch clause.
#
select * from t1
order by a
fetch first 3 row only
offset 2;
a
2
2
3
select * from t1
order by a
fetch first 3 rows only
offset 2;
a
2
2
3
select * from t1
order by a
fetch next 3 row only
offset 2;
a
2
2
3
select * from t1
order by a
fetch next 3 rows only
offset 2;
a
2
2
3
#
# Repeat the tests, but now with WITH TIES.
# WITH TIES requires order by.
#
select * from t1
fetch first 3 row with ties;
ERROR HY000: WITH TIES requires ORDER BY clause to be present
select * from t1
fetch first 3 rows with ties;
ERROR HY000: WITH TIES requires ORDER BY clause to be present
select * from t1
fetch next 3 row with ties;
ERROR HY000: WITH TIES requires ORDER BY clause to be present
select * from t1
fetch next 3 rows with ties;
ERROR HY000: WITH TIES requires ORDER BY clause to be present
select * from t1
order by a
fetch first 3 row with ties;
a
1
1
2
2
select * from t1
order by a
fetch first 3 rows with ties;
a
1
1
2
2
select * from t1
order by a
fetch next 3 row with ties;
a
1
1
2
2
select * from t1
order by a
fetch next 3 rows with ties;
a
1
1
2
2
#
# Include offset before fetch clause.
#
select * from t1
offset 2
fetch first row with ties;
ERROR HY000: WITH TIES requires ORDER BY clause to be present
select * from t1
order by a
offset 2
fetch first 3 row with ties;
a
2
2
3
select * from t1
order by a
offset 2
fetch first 3 rows with ties;
a
2
2
3
select * from t1
order by a
offset 2
fetch next 3 row with ties;
a
2
2
3
select * from t1
order by a
offset 2
fetch next 3 rows with ties;
a
2
2
3
#
# Include offset after fetch clause.
#
select * from t1
fetch first row with ties
offset 2;
ERROR HY000: WITH TIES requires ORDER BY clause to be present
select * from t1
order by a
fetch first 3 row with ties
offset 2;
a
2
2
3
select * from t1
order by a
fetch first 3 rows with ties
offset 2;
a
2
2
3
select * from t1
order by a
fetch next 3 row with ties
offset 2;
a
2
2
3
select * from t1
order by a
fetch next 3 rows with ties
offset 2;
a
2
2
3
drop table t1;
drop table t_keyword;
#
# Test behaviour with a simple select.
#
create table t1 (id int, first_name varchar(100), last_name varchar(100), score double);
insert into t1 values
(1, 'Alice', 'Fowler', 5),
(2, 'John', 'Doe', 6),
(3, 'John', 'Smith', 6),
(4, 'John', 'Smith', 6),
(5, 'John', 'Smith', 7),
(6, 'John', 'Elton', 8.1),
(7, 'Bob',  'Trasc', 9),
(8, 'Silvia', 'Ganush', 10);
create table t2
(id int,
location varchar(100),
fk int,
constraint `fk_t1`
     FOREIGN KEY (fk) REFERENCES t1 (id)
ON DELETE CASCADE
ON UPDATE RESTRICT);
insert into t2 values
(1, 'L1', 1),
(2, 'L2', 2),
(3, 'L3', 3),
(4, 'L3', 4),
(5, 'L4', 5),
(6, 'L4', 6),
(7, 'L4', 7),
(7, null, 8);
select * from t1
order by id
fetch first 3 rows only;
id	first_name	last_name	score
1	Alice	Fowler	5
2	John	Doe	6
3	John	Smith	6
select * from t1
order by id
fetch first 3 rows with ties;
id	first_name	last_name	score
1	Alice	Fowler	5
2	John	Doe	6
3	John	Smith	6
select * from t1
order by first_name
fetch first 3 rows only;
id	first_name	last_name	score
1	Alice	Fowler	5
7	Bob	Trasc	9
3	John	Smith	6
select * from t1
order by first_name
fetch first 3 rows with ties;
id	first_name	last_name	score
1	Alice	Fowler	5
7	Bob	Trasc	9
2	John	Doe	6
3	John	Smith	6
4	John	Smith	6
5	John	Smith	7
6	John	Elton	8.1
#
# Test multi-part order by.
#
select * from t1
order by first_name, last_name
fetch first 3 rows with ties;
id	first_name	last_name	score
1	Alice	Fowler	5
7	Bob	Trasc	9
2	John	Doe	6
select * from t1
order by first_name, last_name
fetch first 4 rows with ties;
id	first_name	last_name	score
1	Alice	Fowler	5
7	Bob	Trasc	9
2	John	Doe	6
6	John	Elton	8.1
select * from t1
order by first_name, last_name
offset 1
fetch first 3 rows with ties;
id	first_name	last_name	score
7	Bob	Trasc	9
2	John	Doe	6
6	John	Elton	8.1
select * from t1
order by first_name, last_name
offset 1
fetch first 3 rows only;
id	first_name	last_name	score
7	Bob	Trasc	9
2	John	Doe	6
6	John	Elton	8.1
select * from t1
order by first_name, last_name
fetch first 3 rows with ties
offset 1;
id	first_name	last_name	score
7	Bob	Trasc	9
2	John	Doe	6
6	John	Elton	8.1
select * from t1
order by first_name, last_name
offset 2
fetch first 3 rows only;
id	first_name	last_name	score
2	John	Doe	6
6	John	Elton	8.1
5	John	Smith	7
select * from t1
order by first_name, last_name
offset 2
fetch first 3 rows with ties;
id	first_name	last_name	score
2	John	Doe	6
6	John	Elton	8.1
3	John	Smith	6
4	John	Smith	6
5	John	Smith	7
select * from t1
order by first_name, last_name
offset 3
fetch first 3 rows only;
id	first_name	last_name	score
6	John	Elton	8.1
3	John	Smith	6
4	John	Smith	6
select * from t1
order by first_name, last_name
offset 3
fetch first 3 rows with ties;
id	first_name	last_name	score
6	John	Elton	8.1
3	John	Smith	6
4	John	Smith	6
5	John	Smith	7
select * from t1
order by first_name, last_name
offset 4
fetch first 3 rows only;
id	first_name	last_name	score
3	John	Smith	6
4	John	Smith	6
5	John	Smith	7
select * from t1
order by first_name, last_name
offset 4
fetch first 3 rows with ties;
id	first_name	last_name	score
3	John	Smith	6
4	John	Smith	6
5	John	Smith	7
#
# Test offset crossing into a new peer-group.
#
select * from t1
order by first_name, last_name
offset 5
fetch first 3 rows with ties;
id	first_name	last_name	score
4	John	Smith	6
5	John	Smith	7
8	Silvia	Ganush	10
select * from t1
order by first_name, last_name
offset 5
fetch first 3 rows only;
id	first_name	last_name	score
4	John	Smith	6
5	John	Smith	7
8	Silvia	Ganush	10
#
# Simple join with 2 tables, order by without columns in the
# second table and also with columns in the second table.
#
# Cover both only and with ties.
#
select t1.id, t1.first_name, t1.last_name, t1.score, t2.location
from t1 inner join t2 on t1.id = t2.fk
order by t1.first_name, t1.last_name
fetch first 3 rows only;
id	first_name	last_name	score	location
1	Alice	Fowler	5	L1
7	Bob	Trasc	9	L4
2	John	Doe	6	L2
select t1.id, t1.first_name, t1.last_name, t1.score, t2.location
from t1 inner join t2 on t1.id = t2.fk
order by t2.location, t1.first_name, t1.last_name
fetch first 3 rows only;
id	first_name	last_name	score	location
8	Silvia	Ganush	10	NULL
1	Alice	Fowler	5	L1
2	John	Doe	6	L2
select t1.id, t1.first_name, t1.last_name, t1.score, t2.location
from t1 inner join t2 on t1.id = t2.fk
order by t1.first_name, t1.last_name
fetch first 3 rows with ties;
id	first_name	last_name	score	location
1	Alice	Fowler	5	L1
7	Bob	Trasc	9	L4
2	John	Doe	6	L2
select t1.id, t1.first_name, t1.last_name, t1.score, t2.location
from t1 inner join t2 on t1.id = t2.fk
order by t2.location, t1.first_name, t1.last_name
fetch first 3 rows with ties;
id	first_name	last_name	score	location
8	Silvia	Ganush	10	NULL
1	Alice	Fowler	5	L1
2	John	Doe	6	L2
#
# Test descending order by.
#
select t1.id, t1.first_name, t1.last_name, t1.score, t2.location
from t1 inner join t2 on t1.id = t2.fk
order by t2.location desc, t1.first_name, t1.last_name
fetch first 3 rows only;
id	first_name	last_name	score	location
7	Bob	Trasc	9	L4
6	John	Elton	8.1	L4
5	John	Smith	7	L4
select * from t2
order by t2.location desc
fetch first 2 rows with ties;
id	location	fk
5	L4	5
6	L4	6
7	L4	7
select * from t2
order by t2.location desc
offset 1
fetch first 2 rows with ties;
id	location	fk
6	L4	6
7	L4	7
select * from t2
order by t2.location desc
offset 2
fetch first 2 rows with ties;
id	location	fk
3	L3	3
4	L3	4
7	L4	7
#
# Test a join with descending order by.
#
select t1.id, t1.first_name, t1.last_name, t1.score, t2.location
from t1 inner join t2 on t1.id = t2.fk
order by t2.location desc, t1.first_name, t1.last_name
fetch first 3 rows with ties;
id	first_name	last_name	score	location
7	Bob	Trasc	9	L4
6	John	Elton	8.1	L4
5	John	Smith	7	L4
#
# Test subqueries.
#
select * from (
select * from t2
order by t2.location desc
offset 2
fetch first 2 rows with ties
) temp;
id	location	fk
7	L4	7
3	L3	3
4	L3	4
select * from t2
order by t2.location desc
offset 0
fetch first 2 rows with ties;
id	location	fk
5	L4	5
6	L4	6
7	L4	7
create view v1 as (
select * from t2
order by t2.location desc
offset 0
fetch first 2 rows with ties
);
create view v2 as (
select * from t2
order by t2.location desc
offset 1
fetch first 2 rows with ties
);
create view v3 as (
select * from t2
order by t2.location desc
offset 2
fetch first row with ties
);
select * from v1;
id	location	fk
5	L4	5
6	L4	6
7	L4	7
select * from v2;
id	location	fk
6	L4	6
7	L4	7
select * from v3;
id	location	fk
7	L4	7
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS (select `t2`.`id` AS `id`,`t2`.`location` AS `location`,`t2`.`fk` AS `fk` from `t2` order by `t2`.`location` desc offset 0 fetch first 2 rows with ties)	latin1	latin1_swedish_ci
show create view v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2` AS (select `t2`.`id` AS `id`,`t2`.`location` AS `location`,`t2`.`fk` AS `fk` from `t2` order by `t2`.`location` desc offset 1 fetch first 2 rows with ties)	latin1	latin1_swedish_ci
show create view v3;
View	Create View	character_set_client	collation_connection
v3	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v3` AS (select `t2`.`id` AS `id`,`t2`.`location` AS `location`,`t2`.`fk` AS `fk` from `t2` order by `t2`.`location` desc offset 2 fetch first 1 rows with ties)	latin1	latin1_swedish_ci
#
# Test joins with views and order by referenced from the view.
#
select *
from t1 inner join v1 on t1.id = v1.fk
order by v1.location desc, t1.first_name
offset 1
fetch first 1 rows with ties;
id	first_name	last_name	score	id	location	fk
5	John	Smith	7	5	L4	5
6	John	Elton	8.1	6	L4	6
select first_name, last_name, sum(score)
from t1
group by first_name, last_name
order by first_name;
first_name	last_name	sum(score)
Alice	Fowler	5
Bob	Trasc	9
John	Doe	6
John	Elton	8.1
John	Smith	19
Silvia	Ganush	10
#
# Test with ties with group by. Make sure that if order by is a less
# specific sort of group by, that WITH TIES still gets executed.
#
select first_name, last_name, sum(score)
from t1
group by first_name, last_name
order by first_name
offset 1
fetch first 2 rows with ties;
first_name	last_name	sum(score)
Bob	Trasc	9
John	Elton	8.1
John	Smith	19
John	Doe	6
#
# Test with ties when an index is used to provide the order by.
#
drop table t1;
drop table t2;
drop view v1;
drop view v2;
drop view v3;
